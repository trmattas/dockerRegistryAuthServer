package main

import (
	"crypto/sha256"
	"encoding/base32"
	//"fmt"
)

// The “kid” field has to be in a libtrust fingerprint compatible format. Such a format can be generated by the following steps:
// 1) Take the DER encoded public key which the JWT token was signed against.
// 2) Create a SHA256 hash out of it and truncate to 240bits.
// 3) Split the result into 12 base32 encoded groups with : as delimiter.
//
// Note: this spec came from https://docs.docker.com/registry/spec/auth/jwt/
func CreateKidFromDer(der []byte) string {
	hash := sha256.New() // create a hasher (object that hashes)

	hash.Write(der) // write our byte array (DER encoded key) into the hasher -- it is now hashed, but we can't use the hashed byte array yet

	hashed := hash.Sum(nil) // append the current hash to our input value -- input is nil, so we get the identity of the hash, as a byte array

	//fmt.Println(hashed) // debugging

	truncatedBitLengthAsBytes := 240 / 8 // we are keeping only 240 bits of the 256-bit hashed value
	hashedTruncated := make([]byte, truncatedBitLengthAsBytes)

	// fill the byte array, up to 240 bits
	for i, _ := range hashedTruncated {
		hashedTruncated[i] = hashed[i]
	}

	// now encode as base 32
	var encodedHashedTruncated []byte
	encodedHashedTruncated = make([]byte, 48)                          // this comes out to be a 48 byte array every time, so set capacity to 48
	base32.StdEncoding.Encode(encodedHashedTruncated, hashedTruncated) //encodedHashedTruncated :=  ... EncodeToString(hashedTruncated)

	//fmt.Println(base32.StdEncoding.EncodeToString(hashedTruncated)) // debugging

	//fmt.Println(string(encodedHashedTruncated)) //debugging

	//fmt.Println(len(encodedHashedTruncated)) // debugging

	// now delimit with ":" into 12 groups, so capacity of 48 + 11
	delimitedEncodedHashedTruncated := make([]byte, 59)

	// how much extra we need to add onto our final byte array index -- we move progressively more off
	// from the original byte array index, by +1 every 4 characters
	extra := 0
	for i, _ := range encodedHashedTruncated {
		if i < 4 { // for the first 4 entries, we just do a direct copy from the source to the destination
			delimitedEncodedHashedTruncated[i] = encodedHashedTruncated[i]
			//fmt.Println(string(delimitedEncodedHashedTruncated)) //debugging
			continue
		}

		// from index 4 and onward, we have some special logic for inserting a ":" (after every 4 characters), while still filling
		// the destination array with all values from the source array
		if i%4 == 0 && i > 3 {
			delimitedEncodedHashedTruncated[i+extra] = []byte(":")[0]
			extra++
		}
		delimitedEncodedHashedTruncated[i+extra] = encodedHashedTruncated[i]
		//fmt.Println(string(delimitedEncodedHashedTruncated)) // debugging
	}

	return string(delimitedEncodedHashedTruncated)
}
